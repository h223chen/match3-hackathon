<!doctype html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta charset="UTF-8" />
        <title>Gems</title>
        <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
        <script src="//cdn.jsdelivr.net/phaser/2.5.0/phaser.min.js"></script>
	<script src="/socket.io/socket.io.js"></script>
	<script>
  	    
  	
</script>
    </head>
    <body>

    <script type="text/javascript">
        var sr;

        window.onload = function() {
            var windowWidth = window.innerWidth;            
            var windowHeight = window.innerHeight;
            if (windowWidth/windowHeight > 1.2){
                windowWidth = windowHeight * 1.2
            }
            else {
                windowHeight = windowWidth / 1.2
            }
            var gemRatio = windowHeight / 340;

            var socket = io();
            sr = socket;

            socket.on('clientReceive', function(data) {
                console.log(data);
                // socket.emit('received from server', {move: data});
            })
            socket.on('whatGameRoom', function(data) {
                console.log(data);
            });

            // TODO MAKE WORK FOR MORE THAN 3 PLAYERS
            socket.on('updateScoreboard', function(data) {
                var myScore = data.scoreboard[socket.id];
                var enemyScore = data.scoreboard[Object.keys(data.scoreboard).filter(k => k != socket.id)[0]];
                $("#myScore").text(myScore);
                $("#enemyScore").text(enemyScore);
            });
            socket.on('gameStart', function(data) {
                $("#myScore").text("");
                $("#enemyScore").text("");
            });

            // Example by https://twitter.com/awapblog
            // Updated by https://twitter.com/boldbigflank

            var game = new Phaser.Game(windowWidth, windowHeight, Phaser.CANVAS, document.getElementById('gems'), { preload: preload, create: create });


            var NUM_X = 6;
            var NUM_Y = 5;
            var GEM_SIZE = 64;
            var GEM_SPACING = 2 * gemRatio + 64 * (gemRatio - 1);
            var GEM_SIZE_SPACED = GEM_SIZE + GEM_SPACING;
            var BOARD_COLS;
            var BOARD_ROWS;
            var MATCH_MIN = 3; // min number of same color gems required in a row to be considered a match


            var gems;
            var selectedGem = null;
            var floatingGem = null;
            var selectedGemStartPos;
            var selectedGemTween;
            var tempShiftedGem = null;
            var allowInput;

            var pathArray = [];
            var lastPoint;

            var dissolveSound;
            var bigDissolveSound;

            var gemKillGroup = 0;

            function preload() {

                game.load.spritesheet("GEMS", "assets/sprites/diamonds32x5.png", GEM_SIZE, GEM_SIZE);

                game.load.audio('bigDissolve', 'assets/audio/bigDissolve.mp3')
                game.load.audio('dissolve', 'assets/audio/dissolve.mp3')
                game.load.audio('move', 'assets/audio/move.mp3')


            }

            function create() {

                // fill the screen with as many gems as possible
                spawnBoard();

                // currently selected gem starting position. used to stop player form moving gems too far.
                selectedGemStartPos = { x: 0, y: 0 };
                
                // used to disable input while gems are dropping down and respawning
                allowInput = false;

                game.input.addMoveCallback(slideGem, this);


                bigDissolveSound = game.add.audio('bigDissolve')
                dissolveSound = game.add.audio('dissolve')

                bigDissolveSound.volume = 0.5;
                dissolveSound.volume = 0.5;

            }

            function point(x, y) {
                return {
                    posX: x,
                    posY: y,
                    getX: function() {
                        return this.posX;
                    },
                    getY: function() {
                        return this.posY;
                    },
                    toString: function() {
                        return "[" + this.posX + "," + this.posY + "]";
                    }
                }
            }

            function releaseGem() {
                floatingGem.destroy();
                if (tempShiftedGem === null) {                    
                    selectedGem.alpha = 1;
                    selectedGem = null;
                    return;
                }

                // when the mouse is released with a gem selected
                // 1) check for matches
                // 2) remove matched gems
                // 3) drop down gems above removed gems
                // 4) refill the board
            
                checkBoardAndKillGemMatches();

                selectedGem.alpha = 1;
                selectedGem = null;
                tempShiftedGem = null;

                pathArray = [];
            }

            function slideGem(pointer, x, y) {

                // check if a selected gem should be moved and do it            
                if (selectedGem && pointer.isDown)
                {
                    floatingGem.x = x - 30;
                    floatingGem.y = y - 70;
                    var cursorGemPosX = getGemPos(x);
                    var cursorGemPosY = getGemPos(y);                
                    var newPoint = point(cursorGemPosX, cursorGemPosY);                    
                    if (!lastPoint) {
                        pathArray.push(newPoint);
                        lastPoint = newPoint;
                        //console.log("SLIDEGEM: " + cursorGemPosX + ", " + cursorGemPosY);
                    } else {
                        if (lastPoint.getX() != cursorGemPosX || lastPoint.getY() != cursorGemPosY) {
                            pathArray.push(newPoint);
                            lastPoint = newPoint;
                            //console.log("SLIDEGEM: " + cursorGemPosX + ", " + cursorGemPosY);
                        }
                    }
                                    
                    if (checkIfGemCanBeMovedHere(selectedGemStartPos.x, selectedGemStartPos.y, cursorGemPosX, cursorGemPosY))
                    {
                        if (cursorGemPosX !== selectedGem.posX || cursorGemPosY !== selectedGem.posY)
                        {
                            // move currently selected gem
                            if (selectedGemTween !== null)
                            {
                                game.tweens.remove(selectedGemTween);
                            }

                            selectedGemTween = tweenGemPos(selectedGem, cursorGemPosX, cursorGemPosY);

                            gems.bringToTop(selectedGem);

                            // if we moved a gem to make way for the selected gem earlier, move it back into its starting position
                            // if (tempShiftedGem !== null)
                            // {
                            //     tweenGemPos(tempShiftedGem, selectedGem.posX , selectedGem.posY);
                            //     swapGemPosition(selectedGem, tempShiftedGem);
                            // }

                            // when the player moves the selected gem, we need to swap the position of the selected gem with the gem currently in that position 
                            tempShiftedGem = getGem(cursorGemPosX, cursorGemPosY);

                            if (tempShiftedGem === selectedGem)
                            {
                                tempShiftedGem = null;
                            }
                            else
                            {                     
                                var moveSound = game.add.audio('move')
                                moveSound.volume = 0.5;
                                moveSound.play();

                                tweenGemPos(tempShiftedGem, selectedGem.posX, selectedGem.posY);
                                swapGemPosition(selectedGem, tempShiftedGem);
                            }
                        }
                    }
                }
            }

            // fill the screen with as many gems as possible
            function spawnBoard() {

                BOARD_COLS = Math.floor(game.world.width / GEM_SIZE_SPACED);
                BOARD_ROWS = Math.floor(game.world.height / GEM_SIZE_SPACED);

                gems = game.add.group();

                for (var i = 0; i < BOARD_COLS; i++)
                {
                    for (var j = 0; j < BOARD_ROWS; j++)
                    {
                        var gem = gems.create(i * GEM_SIZE_SPACED, j * GEM_SIZE_SPACED, "GEMS");
                        gem.name = 'gem' + i.toString() + 'x' + j.toString();
                        gem.inputEnabled = true;
                        gem.events.onInputDown.add(selectGem, this);
                        gem.events.onInputUp.add(releaseGem, this);
                        gem.scale.setTo(gemRatio,gemRatio);
                        randomizeGemColor(gem);
                        setGemPos(gem, i, j); // each gem has a position on the board
                        gem.kill();
                    }
                }

                removeKilledGems();

                var dropGemDuration = dropGems();

                // delay board refilling until all existing gems have dropped down
                game.time.events.add(dropGemDuration * 100, refillBoard);

                allowInput = false;

                selectedGem = null;
                tempShiftedGem = null;
            }

            // select a gem and remember its starting position
            function selectGem(gem) {

                if (allowInput)
                {
                    floatingGem = game.add.sprite(game.input.x - 30, game.input.y - 70, gem.generateTexture());
                    gem.alpha = 0.2;
                    selectedGem = gem;
                    selectedGemStartPos.x = gem.posX;
                    selectedGemStartPos.y = gem.posY;
                }

            }

            function getGemNull(posX, posY) {
                 if (posX < 0 || posX > BOARD_COLS || posY < 0 || posY > BOARD_ROWS) {
                    return null;
                }

                return gems.iterate("id", calcGemId(posX, posY), Phaser.Group.RETURN_CHILD);
            }
            // find a gem on the board according to its position on the board
            function getGem(posX, posY) {               
                return gems.iterate("id", calcGemId(posX, posY), Phaser.Group.RETURN_CHILD);
            }

            // convert world coordinates to board position
            function getGemPos(coordinate) {

                return Math.floor(coordinate / GEM_SIZE_SPACED);

            }

            // set the position on the board for a gem
            function setGemPos(gem, posX, posY) {

                gem.posX = posX;
                gem.posY = posY;
                gem.id = calcGemId(posX, posY);

            }

            // the gem id is used by getGem() to find specific gems in the group
            // each position on the board has a unique id
            function calcGemId(posX, posY) {

                return posX + posY * BOARD_COLS;

            }

            // since the gems are a spritesheet, their color is the same as the current frame number
            function getGemColor(gem) {

                return gem.frame;

            }

            // set the gem spritesheet to a random frame
            function randomizeGemColor(gem) {

                gem.frame = game.rnd.integerInRange(0, gem.animations.frameTotal - 1);

            }

            // gems can only be moved 1 square up/down or left/right
            function checkIfGemCanBeMovedHere(fromPosX, fromPosY, toPosX, toPosY) {

                if (toPosX < 0 || toPosX >= BOARD_COLS || toPosY < 0 || toPosY >= BOARD_ROWS)
                {
                    return false;
                }

                // if (fromPosX === toPosX && fromPosY >= toPosY - 1 && fromPosY <= toPosY + 1)
                // {
                //     return true;
                // }

                // if (fromPosY === toPosY && fromPosX >= toPosX - 1 && fromPosX <= toPosX + 1)
                // {
                //     return true;
                // }

                return true;
            }

            // count how many gems of the same color lie in a given direction
            // eg if moveX=1 and moveY=0, it will count how many gems of the same color lie to the right of the gem
            // stops counting as soon as a gem of a different color or the board end is encountered
            function countSameColorGems(startGem, moveX, moveY) {

                var curX = startGem.posX + moveX;
                var curY = startGem.posY + moveY;
                var count = 0;
                
                if (getGem(curX, curY) == null) { return count; }

                while (curX >= 0 && curY >= 0 && curX < BOARD_COLS && curY < BOARD_ROWS && getGemColor(getGem(curX, curY)) === getGemColor(startGem))
                {

                    count++;
                    curX += moveX;
                    curY += moveY;

                    if (getGem(curX, curY) == null) { return count; }    
                }

                return count;

            }

            // swap the position of 2 gems when the player drags the selected gem into a new location
            function swapGemPosition(gem1, gem2) {

                var tempPosX = gem1.posX;
                var tempPosY = gem1.posY;
                setGemPos(gem1, gem2.posX, gem2.posY);
                setGemPos(gem2, tempPosX, tempPosY);

            }

            // count how many gems of the same color are above, below, to the left and right
            // if there are more than 3 matched horizontally or vertically, kill those gems
            // if no match was made, move the gems back into their starting positions

            function checkCanKillVerticalGemMatches(gem) {
                if (gem === null) { return; }

                var canKill = false;

                // process the selected gem
                if (!gem) { return false; }
                var countUp = countSameColorGems(gem, 0, -1);
                var countDown = countSameColorGems(gem, 0, 1);                            
                var countVert = countUp + countDown + 1;

                if (countVert >= MATCH_MIN) {
                    canKill = true;
                }

                return canKill;
            }

            function checkCanKillHorizontalGemMatches(gem) {
                if (gem === null) { return; }

                var canKill = false;

                // process the selected gem
                if (!gem) { return false; }
                var countLeft = countSameColorGems(gem, -1, 0);
                var countRight = countSameColorGems(gem, 1, 0);
                var countHoriz = countLeft + countRight + 1;

                if (countHoriz >= MATCH_MIN) {
                    canKill = true;
                }

                return canKill;
            }


            function checkNeighborKillGroup(startGem) {

                var curX = startGem.posX;
                var curY = startGem.posY;
                var curColor = startGem.frame;

                var leftGem = getGemNull(curX-1, curY);
                var rightGem = getGemNull(curX+1, curY);
                var topGem = getGemNull(curX, curY-1);
                var bottomGem = getGemNull(curX, curY+1);


                if (leftGem && leftGem.frame === curColor && leftGem.gemKillGroup) {
                    return leftGem.gemKillGroup;
                }

                if (rightGem && rightGem.frame === curColor && rightGem.gemKillGroup) {
                    return rightGem.gemKillGroup;
                }

                if (topGem && topGem.frame === curColor && topGem.gemKillGroup) {
                    return topGem.gemKillGroup;
                }

                if (bottomGem && bottomGem.frame === curColor && bottomGem.gemKillGroup) {
                    return bottomGem.gemKillGroup;
                }

                return numCombos;
            }

            function checkPos(gem, x, y) {
                return gem.posX === x && gem.posY === y;
            }

            function killGemMatches(gem, vertical, horizontal) {
                if (gem === null) { return; }
                var canKill = false;

                // process the selected gem
                if (!gem) { return false; }
                var countUp = countSameColorGems(gem, 0, -1);
                var countDown = countSameColorGems(gem, 0, 1);
                var countLeft = countSameColorGems(gem, -1, 0);
                var countRight = countSameColorGems(gem, 1, 0);

                var countHoriz = countLeft + countRight + 1;
                var countVert = countUp + countDown + 1;

                if (countVert >= MATCH_MIN) {
                    // tweenGemOpacity(gem, 0);
                    if (!gem.dead) {
                        killGemRange(gem.posX, gem.posY - countUp, gem.posX, gem.posY + countDown)
                    }

                    canKill = true;

                    if(canKill){
                    // gemKillGroup++;
                        // removeKilledGems();
                        gem.gemKillGroup = checkNeighborKillGroup(gem);
                        // tweenGemOpacity(gem, 0, 2);
                        allowInput = false;
                    }
                    
                    
                }

                if (countHoriz >= MATCH_MIN) {                   
                    // tweenGemOpacity(gem, 0);
                    if (!gem.dead) {
                        killGemRange(gem.posX - countLeft, gem.posY, gem.posX + countRight, gem.posY);
                    }
                    canKill = true;

                    if(canKill){
                    // gemKillGroup++;

                        // removeKilledGems();
                        gem.gemKillGroup = checkNeighborKillGroup(gem);
                        // tweenGemOpacity(gem, 0, 2);
                        allowInput = false;
                    }
                    
                }
            }

            // check whole board for matches
            function checkBoardAndKillGemMatches() {
                var canKill = false;
                var killCount = 0;
                gemKillGroup = 0;
                var delay = 500;
                for (var i = 0; i < BOARD_COLS; i++)
                {
                    for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    {
                        var gem = getGem(i, j);

                        var canKillHorizontal = checkCanKillHorizontalGemMatches(gem);
                        var canKillVertical = checkCanKillVerticalGemMatches(gem);
                        if (canKillVertical || canKillHorizontal) {
                            allowInput = false;
                            canKill = true;
                                    killGemMatches(gem, canKillVertical,canKillHorizontal);                                        
                            (function(gem, killCount, canKillVertical, canKillHorizontal) {

                                game.time.events.add(delay, function() {
                                    
                                    // if (gem.posX < 0 || gem.posY < 0) { return; }
                                    
                                    if (gem.dead){                                    
                                        game.time.events.add(1000*gem.gemKillGroup , function(){
                                            tweenGemOpacity(gem, 0, 2);
                                        })
                                        
                                    }
                                });
                                
                            }(gem, killCount, canKillVertical, canKillHorizontal));

                            killCount ++;
                        }                   
                    }
                }

                game.time.events.add(5000, function() {
                    for (var i = 0; i < BOARD_COLS; i++)
                    {
                        var tempString = "";
                        for (var j = BOARD_ROWS - 1; j >= 0; j--)
                        {
                            var gem = getGem(i, j);
                            tempString += (gem.gemKillGroup ? gem.gemKillGroup : -1) + '\t';
                        }
                        console.log(i+"\t"+tempString);
                    }
                })
                

                    // for (var i = 0; i < BOARD_COLS; i++)
                    // {
                    //     for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    //     {
                    //         var gem = getGem(i, j);
                    //         if (gem.dead)
                    //             tweenGemOpacity(gem, 0, 2 * (gem.gemKillGroup + 1));
                    //     }                   
                    // }


                if(canKill){
                    game.time.events.add(delay*killCount, function() {
                        var dropGemDuration = dropGems();
                        // delay board refilling until all existing gems have dropped down
                        game.time.events.add(dropGemDuration * 100, refillBoard);
                        allowInput = false;
                    });        
                } else {
                    allowInput = true;
                }
            }

            // kill all gems from a starting position to an end position
            var numCombos = 0;
            var colorMap = {};
            function killGemRange(fromX, fromY, toX, toY) {                    
                fromX = Phaser.Math.clamp(fromX, 0, BOARD_COLS - 1);
                fromY = Phaser.Math.clamp(fromY , 0, BOARD_ROWS - 1);
                toX = Phaser.Math.clamp(toX, 0, BOARD_COLS - 1);
                toY = Phaser.Math.clamp(toY, 0, BOARD_ROWS - 1);

                var alreadyDead = true;
                for (var i = fromX; i <= toX; i++) {
                    for (var j = fromY; j <= toY; j++) {
                        var gem = getGem(i, j);
                        if (gem && gem.alive) {
                            var color = getGemColor(gem);
                            if (colorMap[color]) {
                                colorMap[color] = colorMap[color] + 1;
                            } else {
                                colorMap[color] = 1;
                            }

                            // gem.kill();
                            gem.dead = true;
                            alreadyDead = false;
                        }
                        
                    }
                }

                if (!alreadyDead) {
                    var numKilledGems = 0;
                    for (var key in colorMap) {
                        numKilledGems += colorMap[key];
                    }

                    if (numKilledGems > 15) {
                        if (bigDissolveSound) bigDissolveSound.play();    
                    } else {
                        if (dissolveSound) dissolveSound.play();
                    } 
                    numCombos ++; 
                }
                
            }

            // move gems that have been killed off the board
            function removeKilledGems() {                    
                gems.forEach(function(gem) {
                    if (!gem.alive) {
                        setGemPos(gem, -1,-1);
                    }
                });

            }

            function tweenGemOpacity(gem, newOpacity, durationMultiplier) {
                if (durationMultiplier === null || typeof durationMultiplier === 'undefined')
                {
                    durationMultiplier = 0.75;
                }

                return game.add.tween(gem).to({
                    alpha: newOpacity        
                }, 100 * durationMultiplier, Phaser.Easing.Linear.None, true);
            }

            function tweenGemPos(gem, newPosX, newPosY, durationMultiplier) {
                var midpointX = newPosX, midpointY = newPosY;
                // console.log('Tween ',gem.name,' from ',gem.posX, ',', gem.posY, ' to ', newPosX, ',', newPosY);
                if (durationMultiplier === null || typeof durationMultiplier === 'undefined')
                {
                    durationMultiplier = 0.75;
                    if (newPosY !== gem.posY){
                        midpointX = newPosX + newPosX * (gem === tempShiftedGem ? 0.2 : -0.2);
                    }
                    if (newPosX !== gem.posX) {
                        midpointY = newPosY + newPosY * (gem === tempShiftedGem ? 0.2 : -0.2);
                    }
                }
                return game.add.tween(gem).to({
                    x: [midpointX * GEM_SIZE_SPACED, newPosX * GEM_SIZE_SPACED],
                    y: [midpointY * GEM_SIZE_SPACED, newPosY * GEM_SIZE_SPACED]
                }, 100 * durationMultiplier, Phaser.Easing.Linear.None, true).interpolation(function(v, k){
                        return Phaser.Math.bezierInterpolation(v, k);
                });
            }

            // look for gems with empty space beneath them and move them down
            function dropGems() {

                var dropRowCountMax = 0;

                for (var i = 0; i < BOARD_COLS; i++)
                {
                    var dropRowCount = 0;

                    for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    {
                        var gem = getGem(i, j);

                        if (gem === null)
                        {
                            dropRowCount++;
                        }
                        else if (dropRowCount > 0)
                        {
                            gem.dirty = true;
                            setGemPos(gem, gem.posX, gem.posY + dropRowCount);
                            tweenGemPos(gem, gem.posX, gem.posY, dropRowCount);
                        }
                    }

                    dropRowCountMax = Math.max(dropRowCount, dropRowCountMax);
                }

                return dropRowCountMax;

            }

            // look for any empty spots on the board and spawn new gems in their place that fall down from above
            function refillBoard() {
                gemKillGroup = 0;
                var maxGemsMissingFromCol = 0;

                for (var i = 0; i < BOARD_COLS; i++)
                {
                    var gemsMissingFromCol = 0;

                    for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    {
                        var gem = getGem(i, j);

                        if (gem === null)
                        {
                            gemsMissingFromCol++;
                            gem = gems.getFirstDead();
                            gem.reset(i * GEM_SIZE_SPACED, -gemsMissingFromCol * GEM_SIZE_SPACED);
                            gem.dirty = true;
                            gem.dead = false;

                            randomizeGemColor(gem);
                            setGemPos(gem, i, j);
                            tweenGemPos(gem, gem.posX, gem.posY, gemsMissingFromCol * 2);
                        }
                    }

                    maxGemsMissingFromCol = Math.max(maxGemsMissingFromCol, gemsMissingFromCol);
                }

                game.time.events.add(maxGemsMissingFromCol * 2 * 100, boardRefilled);

            }

            // when the board has finished refilling, re-enable player input
            function boardRefilled() {
                var canKill = false;
                var killCount = 0;
                gemKillGroup = 0;
                var delay = 500;

                // for (var i = 0; i < BOARD_COLS; i++)
                // {
                //     var tempString = "";
                //     for (var j = BOARD_ROWS - 1; j >= 0; j--)
                //     {
                //         var gem = getGem(i, j);
                //         tempString += gem.killgroup + '\t';
                //     }
                //     console.log(tempString);
                // }


                for (var i = 0; i < BOARD_COLS; i++)
                {
                    var tempString = "";
                    for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    {
                        var gem = getGem(i, j);
                        
                        if (gem && gem.dirty)
                        {
                            gem.dirty = false;

                            var canKillHorizontal = checkCanKillHorizontalGemMatches(gem);
                            var canKillVertical = checkCanKillVerticalGemMatches(gem);
                            if (canKillVertical || canKillHorizontal) {
                                allowInput = false;
                                canKill = true;
                                (function(gem, killCount, canKillVertical, canKillHorizontal) {

                                    game.time.events.add(delay*killCount, function() {
                                        if (gem.posX < 0 || gem.posY < 0) { 
                                            return; 
                                        } 
                                        killGemMatches(gem, canKillVertical,canKillHorizontal); 
                                        if (gem.posX < 0 || gem.posY < 0) { 
                                            return; 
                                        }   
                                        console.log(killCount, canKillVertical, canKillHorizontal, gem.posX, gem.posY);
                                    });
                                    
                                }(gem, killCount, canKillVertical, canKillHorizontal));

                                killCount ++;
                            }
                            
                        }
                    }
                }

                if (canKill) {  
                    game.time.events.add(delay*killCount, function() {
                        var dropGemDuration = dropGems();
                        // delay board refilling until all existing gems have dropped down
                        game.time.events.add(dropGemDuration * 100, refillBoard);
                        allowInput = false;
                    });                    
                } else {
                    socket.emit('move', { numCombos: numCombos, colorMap: colorMap });
                    console.log("Number of Combos: " + numCombos);
                    
                    console.log("Color Map :"); 
                    for (var key in colorMap) {
                        console.log(key + " : " + colorMap[key]);
                    }
                    
                    numCombos = 0;
                    colorMap = {};
                    allowInput = true;
                }
            }

            function sleep(seconds) {
              var e = new Date().getTime() + (seconds * 1000);
              while (new Date().getTime() <= e) {}
            }

        };

    </script>
    <div id="gems"></div>
    <h2>Your Score: <span id='myScore'>Waiting for game to start...</span></h2>
    <h2>Your Opponent's Score: <span id='enemyScore'>Waiting for game to start...</span></h2>

    </body>
</html>
