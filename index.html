<!doctype html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta charset="UTF-8" />
        <title>Gems</title>
        <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
        <script src="//cdn.jsdelivr.net/phaser/2.5.0/phaser.min.js"></script>
	<script src="/socket.io/socket.io.js"></script>
    </head>

    <body style="margin:0;">

    <script type="text/javascript">
        // lets browser access socket variable.
        var sr;
        var name = "";

        window.onload = function() {
            //suggested name is in cookie
            name = prompt("Please enter your username:", document.cookie.replace(/(?:(?:^|.*;\s*)name\s*\=\s*([^;]*).*$)|^.*$/, "$1"));
            //save name as cookie
            var date = new Date();
            date.setTime(date.getTime()+(30*1000));
            var expires = "; expires="+date.toGMTString();
            document.cookie = "name"+"="+name+expires+"; path=/";


            loadGame();
        }

        var loadGame = function() {

            var colors = {
                0 : "red",
                1 : "orange",
                2 : "green",
                3 : "purple",
                4 : "blue"
            }

            var leftColumnKill = 0;
            var rightColumnKill = 0;
            var topRowKill = 0;
            var bottomRowKill = 0;

            var windowWidth = window.innerWidth;            
            var windowHeight = window.innerHeight;
            if (windowWidth/windowHeight > 1.2){
                windowWidth = windowHeight * 1.2
            }
            else {
                windowHeight = windowWidth / 1.2
            }

            var gemRatio = windowHeight / 340;
            var scoreText;
            var enemyScoreText;
            var myScore = 0;
            var enemyScore = 0;
            var enemyName;

            var socket = io({query: 'name=' + name});
            sr = socket;

            socket.on('clientReceive', function(data) {
                console.log(data);
                // socket.emit('received from server', {move: data});
            })
            socket.on('whatGameRoom', function(data) {
                console.log(data);
            });
            socket.on('frozenRequest', function(data) {
                pendingFrozenReq += data.attackStrength;
                console.log("increase frozen count to " + pendingFrozenReq);
            });

            function tween(isMyScore, score){
                
            }

            function updateScoreboard(scoreboard) {
                myScore = scoreboard[socket.id];
                enemyScore = scoreboard[Object.keys(scoreboard).filter(k => k != socket.id)[0]];
                if (scoreText) {
                    var pointsTween = gameInfo.add.tween(scoreText);
                    pointsTween.to({ tweenedPoints: myScore}, 180, Phaser.Easing.Linear.None, true);
                    pointsTween.onUpdateCallback(function(){
                        scoreText.setText(name + "\n"+Math.floor(scoreText.tweenedPoints));
                    }, gameInfo);
                    pointsTween.onComplete.addOnce(function(){
                        scoreText.setText(name + "\n"+myScore);
                    }, gameInfo);
                    pointsTween.start();
                }
                if (enemyScoreText) {
                    var enemyPointsTween = gameInfo.add.tween(enemyScoreText);
                    enemyPointsTween.to({ tweenedPoints: enemyScore}, 180, Phaser.Easing.Linear.None, true);
                    enemyPointsTween.onUpdateCallback(function(){
                        enemyScoreText.setText(enemyName +"\n"+Math.floor(enemyScoreText.tweenedPoints));
                    }, gameInfo);
                    enemyPointsTween.onComplete.addOnce(function(){
                        enemyScoreText.setText(enemyName + "\n"+enemyScore);
                    }, gameInfo);
                    enemyPointsTween.start();
                }

            }

            // TODO MAKE WORK FOR MORE THAN 3 PLAYERS
            socket.on('updateScoreboard', function(data) {
                updateScoreboard(data.scoreboard);
            });
            socket.on('gameStart', function(data) {
                enemyName = data.names[Object.keys(data.names).filter(k => k != socket.id)[0]];
                updateScoreboard(data.scoreboard);
                if (data.gameLength >= 10000) {
                    setTimeout(function() {
                        warningSound.play();
                    }, data.gameLength - 10000);
                }
            });

            // end the game
            socket.on('gameEnd', function(data) {
                updateScoreboard(data.scoreboard);
                var victory = myScore > enemyScore;
                var gameOverTextStyle = { boundsAlignH : "center", boundsAlignV: "middle", fill: "#FFF", font: "bold " + (windowWidth / 10)+ "px Helvetica" };
                gameOverText = game.add.text(0, 0, (victory ? "VICTORY" : "DEFEAT"), gameOverTextStyle);
                gameOverText.setTextBounds(0, 0, windowWidth, windowHeight);
                gameOverText.setShadow(3, 3, 'rgba(0,0,0,0.5)', 2);

                if (victorySound && victory) victorySound.play();
                setTimeout(function() {
                    game.paused = true;
                }, 5000);
                console.log("Game end");
            });

            // Example by https://twitter.com/awapblog
            // Updated by https://twitter.com/boldbigflank

            var gameInfo = new Phaser.Game(windowWidth, window.innerHeight - windowHeight, Phaser.CANVAS, document.getElementById('gems'), { preload: preloadInfo, create: createInfo});

            var game = new Phaser.Game(windowWidth, windowHeight, Phaser.CANVAS, document.getElementById('gems'), { preload: preload, create: create });


            var NUM_X = 6;
            var NUM_Y = 5;
            var GEM_SIZE = 64;
            var GEM_SPACING = 2 * gemRatio + 64 * (gemRatio - 1);
            var GEM_SIZE_SPACED = GEM_SIZE + GEM_SPACING;
            var BOARD_COLS;
            var BOARD_ROWS;
            var MATCH_MIN = 3; // min number of same color gems required in a row to be considered a match


            var gems;
            var selectedGem = null;
            var floatingGem = null;
            var selectedGemStartPos;
            var selectedGemTween;
            var tempShiftedGem = null;
            var allowInput;

            var pathArray = [];
            var lastPoint;            

            var frozenGems = [];
            var pendingFrozenReq = 0;

            var moveSound;
            var dissolveSound;
            var bigDissolveSound;
            var lightningSound;
            var victorySound;
            var resolveSound;
            var profitSound;
            var warningSound;

            function preloadInfo() {
                gameInfo.load.audio('bigDissolve', 'assets/audio/bigDissolve.mp3')
                gameInfo.load.audio('dissolve', 'assets/audio/dissolve.mp3')
                gameInfo.load.audio('move', 'assets/audio/move.mp3')
                gameInfo.load.audio('lightning', 'assets/audio/lightning.mp3')
                gameInfo.load.audio('victory', 'assets/audio/victory.mp3')
                gameInfo.load.audio('resolve', 'assets/audio/resolve.mp3')
                gameInfo.load.audio('profit', 'assets/audio/profit.mp3')
                gameInfo.load.audio('warning', 'assets/audio/warning.mp3')
            }

            function createInfo() {
                bigDissolveSound = gameInfo.add.audio('bigDissolve')
                dissolveSound = gameInfo.add.audio('dissolve')
                moveSound = gameInfo.add.audio('move')
                lightningSound = gameInfo.add.audio('lightning')
                victorySound = gameInfo.add.audio('victory')
                resolveSound = gameInfo.add.audio('resolve')
                profitSound = gameInfo.add.audio('profit')
                warningSound = gameInfo.add.audio('warning')


                bigDissolveSound.volume = 0.5;
                dissolveSound.volume = 0.5;
                moveSound.volume = 0.5;
                lightningSound.volume = 0.5;
                victorySound.volume = 0.5;
                resolveSound.volume = 0.5;
                profitSound.volume = 0.5;
                warningSound.volume = 0.5;            }

            function preload() {

                game.load.spritesheet("GEMS", "assets/sprites/diamonds32x5.png", GEM_SIZE, GEM_SIZE);
                game.load.audio('bigDissolve', 'assets/audio/bigDissolve.mp3')
                game.load.audio('dissolve', 'assets/audio/dissolve.mp3')
                game.load.audio('move', 'assets/audio/move.mp3')

                game.load.spritesheet('vortex', 'assets/sprites/vortexSprite.png', 64, 64);
                game.load.image("cross", "assets/sprites/cross64x64.png");
                //game.load.image("ice", "assets/sprites/ice.jpg");


            }

            function create() {

                // fill the screen with as many gems as possible
                spawnBoard();

                // currently selected gem starting position. used to stop player form moving gems too far.
                selectedGemStartPos = { x: 0, y: 0 };
                
                // used to disable input while gems are dropping down and respawning
                allowInput = false;

                game.input.addMoveCallback(slideGem, this);
                //sounds

                bigDissolveSound = game.add.audio('bigDissolve')
                dissolveSound = game.add.audio('dissolve')

                bigDissolveSound.volume = 0.5;
                dissolveSound.volume = 0.5;
                

                // create score textboxes
                scoreText = gameInfo.add.text(10, 10, "Waiting for player two.", { font: Math.floor(windowWidth / 20)+ 'px sans-serif', fill: '#36D7B7' });
                enemyScoreText = gameInfo.add.text(windowWidth * .75, 10, "Insert Coin", { font: Math.floor(windowWidth / 20)+ 'px sans-serif', fill: '#E29C45' });
                scoreText.tweenedPoints = 0;
                enemyScoreText.tweenedPoints = 0;

            }

            function point(x, y) {
                return {
                    posX: x,
                    posY: y,
                    getX: function() {
                        return this.posX;
                    },
                    getY: function() {
                        return this.posY;
                    },
                    toString: function() {
                        return "[" + this.posX + "," + this.posY + "]";
                    }
                }
            }

            function generateCondition() {
                var COMBOS = "6combos";
                var RUNES = "6runes";
                var COLUMNS = "columns";
                var ROWS = "rows";

                var conditionKeys = [COMBOS, RUNES, COLUMNS, ROWS];
                var conditionKey = conditionKeys[Math.floor(Math.random() * conditionKeys.length)];
                var randomColor = Math.floor(Math.random() * Object.keys(colors).length);
                var randomColumnRow = Math.floor(Math.random() * 2)

                var attackConditions = {
                    "6combos" : {
                        checkCondition: function(userObj) {
                            if (userObj.numCombos > 6) {
                                return true;
                            }
                            return false;
                        },
                        description: "make 6 or more combos"
                    },
                    "6runes": {
                        checkCondition: function(userObj) {                            
                            if (userObj.colorMap[randomColor] >= 6) {
                                return true;
                            } 
                            return false;
                        },
                        description: "make 6 or more of " + colors[randomColor]
                    },
                    "columns": {
                        checkCondition: function(userObj) {
                            var conditionMet = randomColumnRow == 0 ? 
                            userObj.dissolvedLeft : 
                            userObj.dissolvedRight;

                            return conditionMet;
                        },
                        description: "Dissolve runes on the " + (randomColumnRow == 0 ? "left" : "right") + " column"
                    },
                    "rows": {
                       checkCondition: function(userObj) {
                            var conditionMet = randomColumnRow == 0 ?
                            userObj.dissolvedTop :
                            userObj.dissolvedBottom;

                            return conditionMet;
                       },
                       description: "Dissolve runes on the " + (randomColumnRow == 0 ? "top" : "bottom") + " row"
                    }
                }                

                var condition = attackConditions[conditionKey];
                condition.name = conditionKey;

                return condition;
            }

            function releaseGem() {
                if (floatingGem == null) return;
                floatingGem.destroy();
                if (tempShiftedGem === null) {                    
                    selectedGem.alpha = 1;
                    selectedGem = null;
                    return;
                }

                // when the mouse is released with a gem selected
                // 1) check for matches
                // 2) remove matched gems
                // 3) drop down gems above removed gems
                // 4) refill the board
            
                checkBoardAndKillGemMatches();

                selectedGem.alpha = 1;
                selectedGem = null;
                tempShiftedGem = null;

                pathArray = [];
            }

            function slideGem(pointer, x, y) {
                // check if a selected gem should be moved and do it            
                if (selectedGem && pointer.isDown)
                {
                    floatingGem.x = x - GEM_SIZE_SPACED / 2;
                    floatingGem.y = y - 70;
                    var cursorGemPosX = getGemPos(x);
                    var cursorGemPosY = getGemPos(y);                
                    var newPoint = point(cursorGemPosX, cursorGemPosY);
                    if (!lastPoint) {
                        pathArray.push(newPoint);
                        lastPoint = newPoint;
                    } else {
                        if (lastPoint.getX() != cursorGemPosX || lastPoint.getY() != cursorGemPosY) {
                            pathArray.push(newPoint);
                            lastPoint = newPoint;
                        }
                    }

                    if (isGemFrozen(point(cursorGemPosX, cursorGemPosY))) {
                        releaseGem();
                    }

                    if (checkIfGemCanBeMovedHere(selectedGemStartPos.x, selectedGemStartPos.y, cursorGemPosX, cursorGemPosY))
                    {
                        if (cursorGemPosX !== selectedGem.posX || cursorGemPosY !== selectedGem.posY)
                        {
                            // move currently selected gem
                            if (selectedGemTween !== null)
                            {
                                game.tweens.remove(selectedGemTween);
                            }

                            selectedGemTween = tweenGemPos(selectedGem, cursorGemPosX, cursorGemPosY);

                            gems.bringToTop(selectedGem);

                            // if we moved a gem to make way for the selected gem earlier, move it back into its starting position
                            // if (tempShiftedGem !== null)
                            // {
                            //     tweenGemPos(tempShiftedGem, selectedGem.posX , selectedGem.posY);
                            //     swapGemPosition(selectedGem, tempShiftedGem);
                            // }

                            // when the player moves the selected gem, we need to swap the position of the selected gem with the gem currently in that position 
                            tempShiftedGem = getGem(cursorGemPosX, cursorGemPosY);

                            if (tempShiftedGem === selectedGem)
                            {
                                tempShiftedGem = null;
                            }
                            else
                            {
                                moveSound.play();

                                tweenGemPos(tempShiftedGem, selectedGem.posX, selectedGem.posY);
                                swapGemPosition(selectedGem, tempShiftedGem);
                            }
                        }
                    }
                }
            }

            // fill the screen with as many gems as possible
            function spawnBoard() {

                BOARD_COLS = Math.floor(game.world.width / GEM_SIZE_SPACED);
                BOARD_ROWS = Math.floor(game.world.height / GEM_SIZE_SPACED);

                gems = game.add.group();

                for (var i = 0; i < BOARD_COLS; i++)
                {
                    for (var j = 0; j < BOARD_ROWS; j++)
                    {
                        var gem = gems.create(i * GEM_SIZE_SPACED, j * GEM_SIZE_SPACED, "GEMS");
                        gem.name = 'gem' + i.toString() + 'x' + j.toString();
                        gem.inputEnabled = true;
                        gem.events.onInputDown.add(selectGem, this);
                        gem.events.onInputUp.add(releaseGem, this);
                        gem.scale.setTo(gemRatio,gemRatio);
                        randomizeGemColor(gem);
                        setGemPos(gem, i, j); // each gem has a position on the board
                        gem.kill();
                    }
                }

                removeKilledGems();

                var dropGemDuration = dropGems();

                // delay board refilling until all existing gems have dropped down
                game.time.events.add(dropGemDuration * 100, refillBoard);

                allowInput = false;

                selectedGem = null;
                tempShiftedGem = null;
            }

            function freezeGemAt(indexX, indexY) {
                var freezeGem = new Object();
                freezeGem.coordinate = point(indexX, indexY);

                var frames = [];

                for (var i=0; i<23; i++) {
                    frames.push(i);
                }

                

                freezeGem.image = game.add.sprite(indexX * GEM_SIZE_SPACED, indexY * GEM_SIZE_SPACED, "vortex");
                freezeGem.image.alpha = 1;
                freezeGem.image.scale.setTo(gemRatio,gemRatio);

                freezeGem.image.frame = 0;
                freezeGem.image.animations.add('play', frames, 24, true);
                freezeGem.image.animations.play('play');

                frozenGems.push(freezeGem);
            }

            function isGemFrozen(point) {
                for (var i = 0; i < frozenGems.length; i++) {
                    if (point.posX == frozenGems[i].coordinate.posX && point.posY == frozenGems[i].coordinate.posY) {
                        return true;
                    }
                }
                return false;
            }

            // select a gem and remember its starting position
            function selectGem(gem) {

                if (allowInput && !isGemFrozen(gem))
                {
                    floatingGem = game.add.sprite(game.input.x - GEM_SIZE_SPACED / 2, game.input.y - 70, gem.generateTexture());
                    floatingGem.scale.setTo(1.1 * gemRatio, 1.1 * gemRatio);
                    gem.alpha = 0.2;
                    selectedGem = gem;
                    selectedGemStartPos.x = gem.posX;
                    selectedGemStartPos.y = gem.posY;
                }

            }

            // find a gem on the board according to its position on the board
            function getGem(posX, posY) {

                return gems.iterate("id", calcGemId(posX, posY), Phaser.Group.RETURN_CHILD);

            }

            // convert world coordinates to board position
            function getGemPos(coordinate) {

                return Math.floor(coordinate / GEM_SIZE_SPACED);

            }

            // set the position on the board for a gem
            function setGemPos(gem, posX, posY) {

                gem.posX = posX;
                gem.posY = posY;
                gem.id = calcGemId(posX, posY);

            }

            // the gem id is used by getGem() to find specific gems in the group
            // each position on the board has a unique id
            function calcGemId(posX, posY) {

                return posX + posY * BOARD_COLS;

            }

            // since the gems are a spritesheet, their color is the same as the current frame number
            function getGemColor(gem) {

                return gem.frame;

            }

            // set the gem spritesheet to a random frame
            function randomizeGemColor(gem) {

                gem.frame = game.rnd.integerInRange(0, gem.animations.frameTotal - 1);

            }

            // gems can only be moved 1 square up/down or left/right
            function checkIfGemCanBeMovedHere(fromPosX, fromPosY, toPosX, toPosY) {

                if (toPosX < 0 || toPosX >= BOARD_COLS || toPosY < 0 || toPosY >= BOARD_ROWS)
                {
                    return false;
                }

                // if (fromPosX === toPosX && fromPosY >= toPosY - 1 && fromPosY <= toPosY + 1)
                // {
                //     return true;
                // }

                // if (fromPosY === toPosY && fromPosX >= toPosX - 1 && fromPosX <= toPosX + 1)
                // {
                //     return true;
                // }

                return true;
            }

            // count how many gems of the same color lie in a given direction
            // eg if moveX=1 and moveY=0, it will count how many gems of the same color lie to the right of the gem
            // stops counting as soon as a gem of a different color or the board end is encountered
            function countSameColorGems(startGem, moveX, moveY) {

                var curX = startGem.posX + moveX;
                var curY = startGem.posY + moveY;
                var count = 0;

                while (curX >= 0 && curY >= 0 && curX < BOARD_COLS && curY < BOARD_ROWS && getGemColor(getGem(curX, curY)) === getGemColor(startGem))
                {
                    count++;
                    curX += moveX;
                    curY += moveY;
                }

                return count;

            }

            // swap the position of 2 gems when the player drags the selected gem into a new location
            function swapGemPosition(gem1, gem2) {

                var tempPosX = gem1.posX;
                var tempPosY = gem1.posY;
                setGemPos(gem1, gem2.posX, gem2.posY);
                setGemPos(gem2, tempPosX, tempPosY);

            }

            // count how many gems of the same color are above, below, to the left and right
            // if there are more than 3 matched horizontally or vertically, kill those gems
            // if no match was made, move the gems back into their starting positions
            function checkAndKillGemMatches(gem) {

                if (gem === null) { return; }

                var canKill = false;

                // process the selected gem

                var countUp = countSameColorGems(gem, 0, -1);
                var countDown = countSameColorGems(gem, 0, 1);
                var countLeft = countSameColorGems(gem, -1, 0);
                var countRight = countSameColorGems(gem, 1, 0);

                var countHoriz = countLeft + countRight + 1;
                var countVert = countUp + countDown + 1;

                if (countVert >= MATCH_MIN)
                {
                    killGemRange(gem.posX, gem.posY - countUp, gem.posX, gem.posY + countDown);
                    canKill = true;
                }

                if (countHoriz >= MATCH_MIN)
                {
                    killGemRange(gem.posX - countLeft, gem.posY, gem.posX + countRight, gem.posY);
                    canKill = true;
                }

                return canKill;

            }

            // check whole board for matches
            function checkBoardAndKillGemMatches() {
                var canKill = false;                
                leftColumnKill = 0;
                rightColumnKill = 0;
                topRowKill = 0;
                bottomRowKill = 0;

                for (var i = 0; i < BOARD_COLS; i++)
                {
                    var tempRow = i + ": ";
                    for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    {
                        var gem = getGem(i, j);

                        if (gem.dirty) { gem.dirty = false; }
                        var tempCanKill = checkAndKillGemMatches(gem);
                        canKill = tempCanKill || canKill;


                        if (tempCanKill) {
                            if (i ==0) {
                                leftColumnKill ++;
                            }
                            if (i== BOARD_COLS-1) {
                                rightColumnKill ++;
                            }
                            if (j ==0) {
                                topRowKill ++;
                            }
                            if (j== BOARD_ROWS-1) {
                                bottomRowKill ++;  
                            }
                        }
                        tempRow += tempCanKill + "\t";
                    }
                }

                if(canKill){
                    removeKilledGems();
                    var dropGemDuration = dropGems();
                    // delay board refilling until all existing gems have dropped down
                    game.time.events.add(dropGemDuration * 100, refillBoard);
                    allowInput = false;
                } else {
                    allowInput = true;
                }
            }

            // kill all gems from a starting position to an end position
            var numCombos = 0;
            var attackCondition = generateCondition();
            var colorMap = {};
            function killGemRange(fromX, fromY, toX, toY) {                    
                fromX = Phaser.Math.clamp(fromX, 0, BOARD_COLS - 1);
                fromY = Phaser.Math.clamp(fromY , 0, BOARD_ROWS - 1);
                toX = Phaser.Math.clamp(toX, 0, BOARD_COLS - 1);
                toY = Phaser.Math.clamp(toY, 0, BOARD_ROWS - 1);

                var alreadyDead = true;
                for (var i = fromX; i <= toX; i++) {
                    for (var j = fromY; j <= toY; j++) {
                        var gem = getGem(i, j);
                        if (gem.alive) {
                            var color = getGemColor(gem);
                            if (colorMap[color]) {
                                colorMap[color] = colorMap[color] + 1;
                            } else {
                                colorMap[color] = 1;
                            }

                            removeFrozenGems(gem);
                            gem.kill();
                            alreadyDead = false;
                        }
                        
                    }
                }

                if (!alreadyDead) {
                    numCombos ++; 
                }
                
            }

            // remove from frozen gem list if it get dissolved
            function removeFrozenGems(gem) {
                var idx = -1;

                for (var i = 0; i < frozenGems.length; i++) {
                    if (frozenGems[i].coordinate.posX == gem.posX && frozenGems[i].coordinate.posY == gem.posY) {
                        idx = i;
                    }
                }

                if (idx >= 0) {
                    frozenGems[idx].image.destroy();
                    frozenGems.splice(idx, 1);
                    resolveSound.play();
                }
            }

            // move gems that have been killed off the board
            function removeKilledGems() {
                var numKilledGems = 0;
                for (var key in colorMap) {
                    numKilledGems += colorMap[key];
                }

                if (numKilledGems > 15) {
                    if (bigDissolveSound) bigDissolveSound.play();
                } else {
                    if (dissolveSound) dissolveSound.play();
                }

                gems.forEach(function(gem) {
                    if (!gem.alive) {
                        setGemPos(gem, -1,-1);
                    }
                });

            }

            function tweenGemPos(gem, newPosX, newPosY, durationMultiplier) {
                var midpointX = newPosX, midpointY = newPosY;                
                if (durationMultiplier === null || typeof durationMultiplier === 'undefined')
                {
                    durationMultiplier = 0.75;
                    if (newPosY !== gem.posY){
                        midpointX = newPosX + newPosX * (gem === tempShiftedGem ? 0.2 : -0.2);
                    }
                    if (newPosX !== gem.posX) {
                        midpointY = newPosY + newPosY * (gem === tempShiftedGem ? 0.2 : -0.2);
                    }
                }
                return game.add.tween(gem).to({
                    x: [midpointX * GEM_SIZE_SPACED, newPosX * GEM_SIZE_SPACED],
                    y: [midpointY * GEM_SIZE_SPACED, newPosY * GEM_SIZE_SPACED]
                }, 100 * durationMultiplier, Phaser.Easing.Linear.None, true).interpolation(function(v, k){
                        return Phaser.Math.bezierInterpolation(v, k);
                });
            }

            // look for gems with empty space beneath them and move them down
            function dropGems() {

                var dropRowCountMax = 0;

                for (var i = 0; i < BOARD_COLS; i++)
                {
                    var dropRowCount = 0;
                    var freezingCellRows = [];

                    for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    {
                        var gem = getGem(i, j);

                        if (gem === null)
                        {
                            dropRowCount++;
                        }
                        else if (dropRowCount > 0)
                        {
                            gem.dirty = true;
                            setGemPos(gem, gem.posX, gem.posY + dropRowCount);
                            tweenGemPos(gem, gem.posX, gem.posY, dropRowCount);
                        }
                    }

                    dropRowCountMax = Math.max(dropRowCount, dropRowCountMax);
                }

                return dropRowCountMax;

            }

            // look for any empty spots on the board and spawn new gems in their place that fall down from above
            function refillBoard() {

                var maxGemsMissingFromCol = 0;

                for (var i = 0; i < BOARD_COLS; i++)
                {
                    var gemsMissingFromCol = 0;

                    for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    {
                        var gem = getGem(i, j);

                        if (gem === null)
                        {
                            gemsMissingFromCol++;
                            gem = gems.getFirstDead();
                            gem.reset(i * GEM_SIZE_SPACED, (-6-gemsMissingFromCol) * GEM_SIZE_SPACED);
                            gem.dirty = true;

                            randomizeGemColor(gem);
                            setGemPos(gem, i, j);
                            tweenGemPos(gem, gem.posX, gem.posY, 4);
                        }
                    }

                    maxGemsMissingFromCol = Math.max(maxGemsMissingFromCol, gemsMissingFromCol);
                }

                game.time.events.add(600, boardRefilled);

            }

            function checkRowDissolved() {

            }

            function checkColumnDissolved() {

            }

            // when the board has finished refilling, re-enable player input
            function boardRefilled() {
                var canKill = false;
                for (var i = 0; i < BOARD_COLS; i++)
                {
                    for (var j = BOARD_ROWS - 1; j >= 0; j--)
                    {
                        var gem = getGem(i, j);

                        if (gem.dirty)
                        {
                            gem.dirty = false;
                            canKill = checkAndKillGemMatches(gem) || canKill;
                        }
                    }
                }

                if(canKill){
                    removeKilledGems();
                    var dropGemDuration = dropGems();
                    // delay board refilling until all existing gems have dropped down
                    game.time.events.add(dropGemDuration * 100, refillBoard);
                    allowInput = false;
                } else {
                    var userObj = { 
                        numCombos: numCombos, 
                        colorMap: colorMap,
                        dissolvedLeft: leftColumnKill == 5,
                        dissolvedRight: rightColumnKill == 5,
                        dissolvedTop: topRowKill == 6,
                        dissolvedBottom: bottomRowKill == 6
                    };

                    var attackConditionFulfilled = attackCondition.checkCondition(userObj);
                    console.log("attack condition fulfilled: " + attackConditionFulfilled);
                    if (attackConditionFulfilled) {
                        profitSound.play();
                    }       

                    socket.emit('move', {
                        numCombos: numCombos,
                        colorMap: colorMap,
                        attackConditionFulfilled: attackConditionFulfilled
                    });             
                    
                    numCombos = 0;
                    colorMap = {};

                    while(pendingFrozenReq > 0) {
                        if (lightningSound) lightningSound.play();
                        freezeGemAt(game.rnd.integerInRange(0, BOARD_COLS - 1), game.rnd.integerInRange(0, BOARD_ROWS - 1));
                        pendingFrozenReq--;
                    }
                    allowInput = true;

                    leftColumnKill = 0;
                    rightColumnKill = 0;
                    topRowKill = 0;
                    bottomRowKill = 0;

                    attackCondition = generateCondition();
                    console.log(attackCondition);
                }
            }

        };

    </script>
    <div id="gems"></div>

    </body>
</html>
